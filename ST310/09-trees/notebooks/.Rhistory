a <- 10
a.b <- 20
a
a <- 10
a.b <- 20
a.b
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
left_ybar <- mean(left_y)
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
right_ybar <- mean(right_y)
split.left <- left_ybar
split.right <- right_ybar
splits <- c(split)
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, y){
}
recursive_split(x,y,10,2)
a[1]
a
a <- recursive_split(x,y,10,2)
a
a[1].left
a[1]
a[1].left
(a[1]).left
a <- recursive_split(x,y,10,2)
b <- a[1]
b
b.left
a <- 10
a.b <- 20
a
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
left_ybar <- mean(left_y)
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
right_ybar <- mean(right_y)
split.left <- left_ybar
split.right <- right_ybar
splits <- c(c(split,left_ybar,right_ybar))
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, y){
}
recursive_split(x,y,10,2)
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
left_ybar <- mean(left_y)
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
right_ybar <- mean(right_y)
split.left <- left_ybar
split.right <- right_ybar
splits <- c(list(split,left_ybar,right_ybar))
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, y){
}
recursive_split(x,y,10,2)
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
left_ybar <- mean(left_y)
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
right_ybar <- mean(right_y)
split.left <- left_ybar
split.right <- right_ybar
splits <- c(c(split,left_ybar,right_ybar))
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- list(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, y){
}
recursive_split(x,y,10,2)
library(hash)
install.packages("hash")
library(hash)
recursive_split(x,y,10,2)
a <- 10
a$b <- 20
a
a
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
left_ybar <- mean(left_y)
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
right_ybar <- mean(right_y)
split$left <- left_ybar
split$right <- right_ybar
splits <- c(split)
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
list(splits,ys)
}
tree_predict <- function(splits, x_test, y){
}
recursive_split(x,y,10,1)
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
left_ybar <- mean(left_y)
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
right_ybar <- mean(right_y)
split$left <- left_ybar
split$right <- right_ybar
splits <- c(split)
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, y){
}
recursive_split(x,y,10,1)
recursive_split(x,y,10,2)
a <- recursive_split(x,y,10,2)
a[1]
a[[1]]
a[[4]]
length(a)
a[1]
a[2]
x<3
y[x<3]
y[x<1]
y[x<-1]
recursive_split(x,y,10,2)
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
splits <- c(split)
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, x, y){
}
recursive_split(x,y,10,2)
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
splits <- c(split)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, x, y){
}
recursive_split(x,y,10,2)
n <- 1000
mixture_ids <- rbinom(n, 1, .5)
x <- rnorm(n) + 3*mixture_ids
y <- rnorm(n) + 3*mixture_ids
qplot(x,y)
recursive_split(x,y,10,2)
y[x<-1]
n <- 1000
mixture_ids <- rbinom(n, 1, .5)
x <- rnorm(n) + 3*mixture_ids
y <- rnorm(n) + 3*mixture_ids
qplot(x,y)
recursive_split(x,y,10,2)
c(1,2,3)[-1]
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
splits <- c(split)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, x, y){
m <- length(splits)
predictions <- c()
for (x_0 in x_test){
if (x_0<=splits[1]){
y_0 <- mean(y[x<=splits[1]])
} else if (x_0>splits[m]){
y_0 <- mean(y[x>splits[m]])
} else {
for (i in 1:(m-1)){
if (splits[i]<x_0<=splits[i+1]){
0<=x<=1
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
splits <- c(split)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, x, y){
m <- length(splits)
predictions <- c()
for (x_0 in x_test){
if (x_0<=splits[1]){
y_0 <- mean(y[x<=splits[1]])
} else if (x_0>splits[m]){
y_0 <- mean(y[x>splits[m]])
} else {
for (i in 1:(m-1)){
left <- splits[i]
right <- splits[i+1]
if ( x_0<=right & x_0>left ){
y_0 <- mean(y[x<=right&x>left])
break
}
}
}
predictions <- c(predictions, y_0)
}
}
predictions
recursive_split <- function(x,y, min_obs, max_split=5){
if (max_split == 0 || length(x) <= min_obs) {
return() }
split <- tree_split(x,y,min_obs)
splits <- c(split)
left_ind <- which(x <= split)
left_x <- x[left_ind]
left_y <- y[left_ind]
right_ind <- which(x > split)
right_x <- x[right_ind]
right_y <- y[right_ind]
splits_left <- recursive_split(left_x, left_y, min_obs, max_split-1)
splits_right <- recursive_split(right_x, right_y, min_obs, max_split-1)
splits <- c(splits_left, splits, splits_right)
splits
}
tree_predict <- function(splits, x_test, x, y){
m <- length(splits)
predictions <- c()
for (x_0 in x_test){
if (x_0<=splits[1]){
y_0 <- mean(y[x<=splits[1]])
} else if (x_0>splits[m]){
y_0 <- mean(y[x>splits[m]])
} else {
for (i in 1:(m-1)){
left <- splits[i]
right <- splits[i+1]
if ( x_0<=right & x_0>left ){
y_0 <- mean(y[x<=right&x>left])
break
}
}
}
predictions <- c(predictions, y_0)
}
predictions
}
splits <- recursive_split(x,y,10,2)
splits <- recursive_split(x,y,10,2)
splits
tree_predict(splits, c(1,2,3),x,y)
table(c(0,1,0))
n <- 10
mixture_ids <- rbinom(n, 1, .5)
x <- rnorm(n) + 3 * mixture_ids
y <- rnorm(n) + 3 * mixture_ids
# Create classification labels
class_labels <- ifelse(mixture_ids == 1, 'Class 1', 'Class 0')
class_labels
n <- 10
x <- rnorm(n)
linear_combination <- 0.5 * x
prob <- 1 / (1 + exp(-linear_combination))
y <- rbinom(n, 1, prob)
classifier_split <- function(x, y, min.obs = 10) {
x_order <- order(x)
X <- x[x_order]
Y <- y[x_order]
n <- length(x)
if (n > min.obs) {
Ginis <- numeric(length = n - 1)
Ginis[1:length(Ginis)] <- Inf
for (i in 1:(n - 1)) {
Y_left <- Y[1:i]
Y_right <- Y[(i + 1):n]
p_left <- table(Y_left) / length(Y_left)
p_right <- table(Y_right) / length(Y_right)
Gini_left <- 1 - sum(p_left^2)
Gini_right <- 1 - sum(p_right^2)
Ginis[i] <- Gini_left + Gini_right
}
X[which.min(Ginis)]
} else {
return()
}
}
n <- 100
x <- rnorm(n)
linear_combination <- 0.5 * x
prob <- 1 / (1 + exp(-linear_combination))
y <- rbinom(n, 1, prob)
classifier_split(x,y)
n <- 100
x <- rnorm(n)
linear_combination <- 0.5 * x
prob <- 1 / (1 + exp(-linear_combination))
y <- rbinom(n, 1, prob)
qplot(x,y)
classifier_split(x,y)
classifier_split <- function(x, y, min.obs = 10) {
x_order <- order(x)
X <- x[x_order]
Y <- y[x_order]
n <- length(x)
if (n > min.obs) {
Ginis <- numeric(length = n - 1)
Ginis[1:length(Ginis)] <- Inf
for (i in 1:(n - 1)) {
Y_left <- Y[1:i]
Y_right <- Y[(i + 1):n]
p_left <- table(Y_left) / length(Y_left)
p_right <- table(Y_right) / length(Y_right)
Gini_left <- 1 - sum(p_left^2)
Gini_right <- 1 - sum(p_right^2)
Ginis[i] <- (length(Y_left) / n) * Gini_left + (length(Y_right) / n) * Gini_right
}
X[which.min(Ginis)]
} else {
return()
}
}
n <- 100
x <- rnorm(n)
linear_combination <- 0.5 * x
prob <- 1 / (1 + exp(-linear_combination))
y <- rbinom(n, 1, prob)
qplot(x,y)
classifier_split(x,y)
n <- 100
x <- runif(n)
y <- ifelse(x > 0.5, 1, 0)
qplot(x,y)
classifier_split(x,y)
n <- 100
x <- runif(n)
noise <- rbinom(n, 1, 0.1)
y <- ifelse(x > 0.5, 1, 0)
y <- ifelse(noise == 1, 1 - y, y)
qplot(x,y)
classifier_split(x,y)
classifier_split <- function(x, y, min.obs = 10) {
x_order <- order(x)
X <- x[x_order]
Y <- y[x_order]
n <- length(x)
if (n > min.obs) {
Ginis <- numeric(length = n - 1)
Ginis[1:length(Ginis)] <- Inf
for (i in 1:(n - 1)) {
Y_left <- Y[1:i]
Y_right <- Y[(i + 1):n]
p_left <- table(Y_left) / length(Y_left)
p_right <- table(Y_right) / length(Y_right)
Gini_left <- 1 - sum(p_left^2)
Gini_right <- 1 - sum(p_right^2)
#Ginis[i] <- (length(Y_left) / n) * Gini_left + (length(Y_right) / n) * Gini_right
Ginis[i] <- Gini_left +  Gini_right
}
X[which.min(Ginis)]
} else {
return()
}
}
classifier_split(x,y)
floor(5)
floor(5.1)
# Recursive algorithm to calculate factorial
factorial_recursive <- function(n) {
if (n == 0) {
return(1)
} else {
return(n * factorial_recursive(n - 1))
}
}
result <- factorial_recursive(5)
print(result)
# Recursive function to find the sum of a range, applying to two sides
sum_recursive <- function(start, end) {
if (start > end) {
return(0)
} else if (start == end) {
return(start)
} else {
mid <- floor((start + end) / 2)
left_sum <- sum_recursive(start, mid)
right_sum <- sum_recursive(mid + 1, end)
return(left_sum + right_sum)
}
}
result <- sum_recursive(1, 10)
print(result)
# Recursive function to find the sum of a range, applying to two sides
sum_recursive <- function(start, end) {
if (start > end) {
return(0)
} else if (start == end) {
return(start)
} else {
mid <- floor((start + end) / 2)
left_sum <- sum_recursive(start, mid)
right_sum <- sum_recursive(mid + 1, end)
print(left_sum)
print(right_sum)
return(left_sum + right_sum)
}
}
result <- sum_recursive(1, 10)
print(result)
# Recursive function to find the sum of a range, applying to two sides
sum_recursive <- function(start, end) {
if (start > end) {
return(0)
} else if (start == end) {
return(start)
} else {
mid <- floor((start + end) / 2)
left_sum <- sum_recursive(start, mid)
right_sum <- sum_recursive(mid + 1, end)
return(left_sum + right_sum)
}
}
result <- sum_recursive(1, 10)
print(result)
